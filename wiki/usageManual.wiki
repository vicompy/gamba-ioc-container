#summary Gamba Container Usage Manual
#labels Featured

= Table Of Contents =
<wiki:toc max_depth="3" />


= Introduction =

Gamba Container is an ultra-lightweight IoC Container that brings you the benefits of Dependency-Injection and Inversion of Control patterns for your Java applications, with a non-intrusive API that sizes around 20Kb. This article will introduce you to the usage of this container, with a lot of friendly examples.

Gamba Container helps you to design better software, decoupling it in a reusable components.


== Why Gamba? ==

_Gamba_ means shrimp in spanish, and almost all classes are so called Gamba, in order to prevent naming confusions with other APIs or system classes.


== How Gamba Works ==

`Gamba Container` is an IoC container, that provides a consistent way to configure and manage Java objects, 
and to wire her dependant instances. These Java objects will be called as Beans in this tutorial, only for 
historical motives, although they can be complex objects, not limited to Java-Bean properly conventions.

Beans and his dependencies are declared by loading a properties file (called context file), that contains 
the suitable definitions.

Objects can be obtained by means of container asking for an object with a specific identifier. The 
declared dependencies are also injected as defined, recursively.

By defining bean dependencies in a properties way, you may take the following advantages:

    * declarations are focused in a single file per context, allowing to use multiple if required.
    * avoids the Container to use a heavy-weight XML parser.
    * contexts are declared parsing a concise declaration language, more readable, easy to write and to mantain than XML.




== Gamba Container Works Following The Property-Based Recipe ==


Unlike other containers, Gamba dont works following an XML configuration file. For a simple parsing it uses a properties file, under the syntax:

{{{
 #
 #  <BEANDEFINITION> ::= BEANID "=" <BEANDEF>
 #  <BEANDEF> ::= ["~"] CLASS [<CONSTRUCTORINJ>] <METHODINJREP> ";"
 #
 #  <CONSTRUCTORINJ> ::= "(" <INJELEM> {"," <INJELEM>} ")"
 #
 #  <METHODINJREP> ::= {<METHODINJ>}
 #  <METHODINJ> ::= ":" METHODNAME "<-" <INJELEM>
 #
 #  <INJELEM> ::=    "\"" STRINGVALUE "\""
 #                   | "{" <BEANDEF> "}"
 #                   | BEANID
 #
}}}

Here an example:

{{{
controller = ~org.lechuga.gromenauer.ui.Controller;

text-area = org.lechuga.gromenauer.ui.CTextArea;

frame = ~org.lechuga.gromenauer.ui.CFrame (text-area)   \
        : addWindowListener <- controller               \
        : setTitle <- "GROMENAUER"                      \
        : setLocation <- {                              \
                java.awt.Point(                         \
                    {java.lang.Integer("300");},        \
                    {java.lang.Integer("200");}         \
                );                                      \
            }                                           \
        : setSize <- {                                  \
                java.awt.Dimension(                     \
                    {java.lang.Integer("600");},        \
                    {java.lang.Integer("400");}         \
                );                                      \
            }                                           \
        ;

berbis-props = org.berbis.main.BerbisProps({org.berbis.main.Props;});
properties-chooser = org.berbis.main.PropertiesChooser(frame, berbis-props);
}}}









= Usage Manual =


== Using The Container As a Factory, And No More `new` Statements! ==

In this first example we learn how to obtain class instances from a Gamba Container, and how it 
decouples your component implementation from each others.

Everybody knows that hardcoding is a bad practice... but whenever you place a `new` statement in your 
code, you are really taking a concrete class implementation in a hardcoded way! For example, supposing 
that you wants for a `java.util.List` implementation instance, and you choose a `java.util.ArrayList`:

{{{
	List<Integer> list = (List<Integer>) new ArrayList();
}}}

Well, but if you want to choose another implementation for a `List`, you will have to change all your 
classes that `new`s it. Lechuga solves this problem, since the concrete implementation class is 
uniquely declared in a context file as is:

{{{
	myList = java.util.ArrayList;
}}}
	

After declaring the class implementation, you can obtain an instance of this, calling the 
Gamba Container:

	
{{{
	GambaContext gc = GambaContainer.getContext("tips-context.properties");
	List<Integer> myList = (List<Integer>) gc.getBean("myList");

	Assert.assertTrue(myList instanceof List);
}}}
	

Now, if you want to choose another implementation for a `List` (i.e. `LinkedList`), you only must have 
to change the class specified in a context file, and all your classes that instantiates it will obtain 
the new implementation:

{{{
	myList = java.util.LinkedList;
}}}
	







== Dependency Injection ==

Dependency Injection means to inject recursively into your requested bean instance his declared dependencies.
This feature allows you to obtain a desired bean instance (obtained by a Factory, in fact), fully configured 
and ready to use, altought his object-dependencies are being injected.

For example, suppose that you have in hands:

{{{	
		a = gamba.container.test.entities.A \
			:setB <- b;
		
		b = gamba.container.test.entities.B;	
}}}	
	

When you asks the container for an "a" instance, the container works for you and performs reflect operations 
to do the same as the following piece of code:

	
{{{	
		A a = new A();
		B b = new B();
		a.setB(b);
		return a;
}}}	
	

== Setter Injection ==

In the above example, a "b" instance are being injected to an "a" instance using setter injection. 
It is defined with:

	
{{{	
		{: METHOD <- BEANID}
}}}	
	

== Constructor Injection ==

A constructor injection is another kind of injection. For example the definition:

	
{{{	
		a = gamba.container.test.entities.A;
		b = gamba.container.test.entities.B;		
		
		c = gamba.container.test.entities.C :(a, b);	
}}}	
	

will cause that when a "c" instance is requested, container performs:

{{{	
		A a = new A();
		B b = new B();
		C c = new C(a, b);
		return c;
}}}	
	

Construction injection is defined by the syntax:

		
{{{	
		[:(BEANID {, BEANID})]
}}}	










== Character "~" Means Singleton ==

Note that the following declaration

{{{
		b = ~gamba.container.test.entities.B;
}}}

defines the bean identified by "b" as a Singleton object; that is, for every "b" instance that you 
asks, the container will return the same instance.


== Gamba Container Don't Works Lazily ==



